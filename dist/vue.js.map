{"version":3,"file":"vue.js","sources":["../src/observe/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["class Observer {\r\n  constructor(data) {\r\n    // Object.defineProperty只能劫持已经存在的属性，后续增加的或者删除的它无法检测到（vue2中会为此单独写一些API）\r\n    // 遍历当前属性\r\n    this.walk(data)\r\n  }\r\n  walk(data) {\r\n    // 循环对象，对属性依次劫持\r\n    // 重新定义属性，所以这也是vue2的一个性能问题\r\n    Object.keys(data).forEach(key => defineReactive(data, key, data[key]))\r\n  }\r\n}\r\n\r\n// 形成了个闭包\r\nexport function defineReactive(target, key, value) {\r\n  // 如果value是对象，只能劫持第一层，因此还需要再深度劫持\r\n  observe(value)\r\n  // defineProperty方法：第一个参数为需要定义属性的对象\r\n  // 第二个参数为需要定义的属性名\r\n  // 第三个参数为属性描述符\r\n\r\n  // 变量不被销毁是因为：get set监听事件是全局事件，不被销毁，内部函数保存着外部函数的作用域，所以外部函数有引用，也不会被销毁\r\n  Object.defineProperty(target, key, {\r\n    // set、get是defineProperty的内置方法\r\n    get() {\r\n      // 取值的时候，会执行get\r\n      console.log('用户取值了')\r\n      return value\r\n    },\r\n    set(newVal) {\r\n      // 修改的时候，会执行set\r\n      console.log('用户设置值')\r\n      if (newVal === value) return\r\n      value = newVal\r\n    }\r\n  })\r\n}\r\n\r\nexport function observe(data) {\r\n  // 对这个对象进行劫持\r\n  // 只对对象进行劫持\r\n  if (typeof data !== 'object' || data == null) {\r\n    return\r\n  }\r\n  // 如果一个对象已经被劫持过了，那么就不需要再被劫持\r\n  // 要判断一个对象是否被劫持过，可以添加一个实例，用实例来判断\r\n  return new Observer(data)\r\n}\r\n","import { observe } from './observe/index.js'\r\n\r\nexport function initState(vm) {\r\n  // 对数据进行劫持，获取所有选项\r\n  const opts = vm.$options\r\n  if (opts.data) {\r\n    initData(vm)\r\n  }\r\n}\r\n\r\nfunction proxy(vm, target, key) {\r\n  // vm.name\r\n  Object.defineProperty(vm, key, {\r\n    get() {\r\n      return vm[target][key] // vm._data.name\r\n    },\r\n    set(newVal) {\r\n      vm[target][key] = newVal\r\n    }\r\n  })\r\n}\r\n\r\nfunction initData(vm) {\r\n  // data可能是函数也可能是对象\r\n  let data = vm.$options.data\r\n  data = typeof data == 'function' ? data.call(vm) : data\r\n  //   console.log(data)\r\n  //   对数据进行劫持\r\n  vm._data = data\r\n  observe(data)\r\n\r\n  //  将vm._data用vm来代理\r\n  for (let key in data) {\r\n    proxy(vm, '_data', key)\r\n  }\r\n}\r\n","import { initState } from './state'\r\n\r\n// 给Vue增加init方法\r\nexport function initMixin(Vue) {\r\n  // 用于初始化操作\r\n  Vue.prototype._init = function (options) {\r\n    // 原型中的this指的都是实例\r\n    const vm = this\r\n    // vm.$options 获取用户的配置\r\n    // 将options挂载到实例上\r\n    vm.$options = options\r\n\r\n    // 初始化状态\r\n    initState(vm)\r\n  }\r\n}\r\n","import { initMixin } from './init'\r\n// es5中Vue是通过构造函数然后扩展方法，然后将不同的方法放到不同的文件中\r\n// es6是将所有原型方法放在类中\r\nfunction Vue(options) {\r\n  // debugger\r\n  // 默认调用init\r\n  this._init(options)\r\n}\r\n\r\n// 初始化，扩展了init方法\r\ninitMixin(Vue)\r\n\r\nexport default Vue\r\n"],"names":["Observer","data","walk","Object","keys","forEach","key","defineReactive","target","value","observe","defineProperty","get","console","log","set","newVal","initState","vm","opts","$options","initData","proxy","call","_data","initMixin","Vue","prototype","_init","options"],"mappings":"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"}